---
title: "JAVA LV 2-5"
subtitle: "비트 연산자"
layout: post
author: "Gihoon"
date: 2023-03-14 02:00:00
header-style: text
hidden: true
tags:
  - java
---
## 비트 연산자 & | ^ << >>
비트 연산자는 피연산자를 비트단위로 논리 연산한다. 피연산자를 이진수로 표현했을 때의 각자리를 규칙에 따라 연산을 수행하며, 피연산자로 실수는 허용되지 않고 정수만 가능하다.
**| (or연산자) 피연산자 중 한쪽의 값이 1이면 1을 결과로 얻는다 그외에는 0을 얻는다**
**& (AND 연산자) 피연산자 양 쪽이 모두 1이어야만 1을 결과로 얻는다 그외에는 0을 얻는다**
**^ (XOR 연산자) 피연산자의 값이 서로 다를 때만 1을 결과로 얻는다 같을때는 0을 얻는다**

**비트 연산자 | 는 주로 특정 비트의 값을 변경 할 때 사용한다.**
OxAB : 10101011
 OXF : 00001111
     = 10101111:0xAF

**비트연산자 & 는 주로 특정 비트의 값을 뽑아 낼 때 사용한다. 아래의 식에서는 피연산자의 마지막 4bit가 어떤 값인지 알아내는데 사용하였다.**
OxAB : 10101011*
 OXF : 00001111
     = 00001011:0xB

**비트연산자 ^는 간단한 암호화에 사용된다**

**비트 전환 연산자 ~**
이 연산자는 피연산자를 2진수로 표현했을 때, 0은 1로 1은 0으로 바꾼다. 논리 부정 연산자! 와 유사하다.
'~'에 의해 비트전환 되고 나면 부호있는 타입의 연산자는 부호가 반대로 변경된다. 즉 피연산자의 '1의 보수를 얻을수 있는 것이다.
따라서 비트전환연산자를 '1의 보수'연산자라고도 한다.

**쉬프트 연산자 << >>**
이 연산자는 피연산자의 각 자리를 '오른쪽 >> , 왼쪽 <<'으로 이동한다고 해서 쉬프트 연산자이다.
예를 들어 '8<<2'는 왼쪽 피연산자인 10진수 8의 2진수를 왼쪽으로 2자리 이동한다. 
이 떄, 자리이동으로 저장범위를 벗어난 값들은 버려지고 빈자리는 0으로 채워진다.
(1) 10진수 8의 2진수는 00001000 이다
(2)  8<<2 10진수 8의 2진수를 왼쪽으로 2자리 이동시킨다
(3) 자리이동으로 인해 저장범위를 벗어난 값은 버려지고 빈자리는 0으로 채워진다.
(4) 결과는 00100000 이 된다 (10진수로 32)
>> 연산자의 경우에는 오른쪽으로 이동 시키기 때문에 부호있는 정수는 부호를 유지하기 위해 왼쪽 피연산자가 음수인 경우 빈자리를 1로 채운다.






